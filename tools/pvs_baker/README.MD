# English
In future, sorry....


# Russian
Программа для запекания окклюзии, PVS, если быть точнее (Potentially visible set). В Квейке это работает на порталах, но это чот прям тяжело для реализации, да и точность хромает.

У этой программы очень странный принцип работы, т.к. я не вытянул в математику, то решил идти по пути рендера на видеокарте.

Принцип работы:
1. Загрузка .obj карты и установка каждому объекту уникального цвета с шагом 16 на канал, т.е. всего поддерживает 4096 объектов, но шаг можно уменьшить, заменив параметры в некоторых местах, но это сильно увеличит потребление памяти. Главное чтоб шаг был степенью двойки, иначе деление будет медленное, т.к. тупо битовый сдвиг вправо.

2. Нахождение минимальных и максимальных x, y, z у мира, т.е. создание AABB. Разбиение этой области на ячейки с указанным размером (не влияет на скорость, но очень влиеят на вес выходного файла, n<sup>3</sup>). Разбиение каждой области на точки с указанным шагом (влиеяет очень на скорость, n<sup>3</sup>)

3. Далее идёт итерация по ячейкам и рендер с расчётами каждой точки
    1. Проверка на доступность рендерера (их несколько)
    2. Если доступен, то запуск рендерера в указанной точке. Он рендерит изображение в 6-ти направлениях (cubemap, но слегка кривой, на результат никак не влияет). Рендеринг каждого направления происходит в отдельный FBO, а после рендера запускается асинхронное копирование FBO в PBO. После вызова рендера всех сторон, устанавливается Забор синхронизации (FenceSync), чтоб знать когда завершится копирование данных в PBO.
    3. Пока данные копируются, видеокарта простаивает, для этого запускается следующий рендерер и цикл повторяется.
    4. Если видим, что рендерер завершил копирование, то получаем указатели на каждый из PBO (6 штук) этого рендерера и запускаем поток на обработку этих изображений. Создаём массив bool[n][n][n], где n - количество цветов на канал. Обрабатываем все точки и сохраняем в массив уникальные цвета для этой точки. Далее добавляем уникальные цвета в такой-же, но глобальный массив ячейки, через ИЛИ.

4. Как завершается рендер ячейки, дожидаемся завершения всех потоков в ThreadPool и запускаем уже поток на обработку глобального массива цветов, где через HashMap сопоставляем цвет и имя объекта. В конце кэшируем объекты каждой точки и сохраняем на диск. Когда запустили поток, возвращаемся к пункту 3 и продолжаем рендер.

5. После рендера всех ячеек, объединяем кэшированные данные в .hepvs, всё.

Вообще, можно попробовать использовать вычислетельные шейдеры, чтоб не насиловать ЦП и ОЗУ, но Apple мудаки и прекратили поддержку OpenGL на версии 4.1, а вычислительные шейдеры появились только в 4.3. Разбираться в их Metal API желания нет, т.к. не будет кроссплатформы

<br>

### Про формат файла

Формат называется .hepvs (HateEnginePVS)\
Состоит из 3-х основных частей: Заголовок формата, блок с именами объектов, блок с Ячейками

#### Заголовок формата (занимает строго 20 байт):
- Первые 4 байта - версия формата, сделал на всякий случай
- 4 байта - float, минимальная координата по X
- 4 байта - float, минимальная координата по Y
- 4 байта - float, минимальная координата по Z
- 4 байта - float, размер ячейки
- 2 байта - количство ячеек по X
- 2 байта - количство ячеек по Y
- 2 байта - количство ячеек по Z
- 2 байта - количство объектов (имён объектов)

#### Блок с именами объектов:
Массив состоящий из имён объектов
##### Структура имени объекта:
- 2 байта - длина имени
- n байт  - само имя в UTF-8, без \0 (not null-terminated)

#### Блок с Ячейками:
Массив состоящий из Ячеек
##### Структура Ячейки:
- 2 байта  - количество индексов на объекты в ячейке
- 2*n байт - массив индексов (u16) на объекты

##### Массив ячеек имеет следующую стурктуру
X [0]
- Y [0]
    - Z [0] - cell 0
    - Z [1] - cell 1
- Y [1]
    - Z [0] - cell 2
    - Z [1] - cell 3

X [1]
- Y [0]
    - Z [0] - cell 4
    - Z [1] - cell 5
- Y [1]
    - Z [0] - cell 6
    - Z [1] - cell 7

В памяти будет:
```
[cell0, cell1, cell2, cell3, cell4, cell5, cell6, cell7, cell8]
```
