# Заметки по движку

## Работа с ресурсами: звук, модели, карты, текстуры
Поддерживает загрузку сырых ресурсов с диска: .gltf, .glb, .obj (с .map) для карт из TrenchBroom, .png, .jpg.

Придуман формат ресурсов .her, написан упаковщик с графическим интерфейсом на Rust, [ссылка](https://github.com/Apsapeh/HateEngine/tree/master/tools/her_packer). Формат поддерживает шифрование с помощью алгоритма Blowfish, может упаковывать абсолютно любые файлы.

В данный момент движок может считывать заголовок формата и загружать текстуры.

### Aнимации
Пока решено сделать отдельный формат для хранения тупо набора вершин для каждого кадра анимации (.hea (HateEngineAnimation)) и напиасть плагин для блендера для экспорта скелетной анимации в этот формат.
Формат файла уже стал классическим для меня: заголовок формата, набор заголовков анимаций с данными.
##### Заголовок:
- 4 байта - версия формата
- 2 байта - количество анимаций

##### Заголовок анимации:
- 1 байт  - длина названия анимации
- n байт  - null-terminated строка, длина максимум 254 символа + \0
- 2 байта - FPS, целое число
- 2 байта - количество кадров 
- 1 байт  - режим хранения анимаций.

Если 0 режим (индексы вершин у каждого кадра одинаковые):
- 1 байт - тип индексов (1 - short, 2 - int, 3 - long long)
- 8 байт - количество индексов
- n байт - набор самих индексов
Далее повторяется для каждого кадра анимации
    - 8 байт - количество нормалей
    - n байт - набор самих нормалей в float
    - 8 байт - количество вершин
    - n байт - набор самих вершин в float

Остальных режимов нет, но можно добавить, чтоб каждый кадр был уникальный меш


## Системы координат
OGL = {x, y, z} - эталон\
GLM = {-x, -y, -z}\
ReactPhysics3D = {z, y, x}

# Нужно сделать
Сделать норм классы света
Сделать фоновое освещение для уровня

<br>

# Известные баги
1. При отключении тумана начинюатся проблемы с пропаданием меша если есть на сцене OmniLight. Причина неизвестна.

2. Object::getRotationEuler() возвращает какую-то хрень. У меня есть проблемы с линалом.

3. OpenGL15::renderCamera() использует только вращение самой камеры для вращение мира, т.е. при прикреплении к какому-то объекту, камера не будет принимать его вращение (только позицию и позицию с учётом смещения и вращения родительского объекта)

4. На Windows с проблемами работает захват курсора, т.к. этот метод должен вызываться только из главного потока